- name: temp
  type: no_change
  in_block: true
  formatted: |
      // todo prefer breaking on the outer struct
      self.handle_whitespace_and_comments(WhitespaceMode::Vertical(
          NewlineKind::IfComments,
      ));
      self.handle_whitespace_and_comments(
          WhitespaceMode::Vertical(NewlineKind::IfComments),
      );
      
      // todo don't break this chain
      let newlines = token_str.bytes().filter(|&b| b == b'\n').count();
      rustc_lexer::tokenize(self.remaining()).next().unwrap();
      let initial_used_width = before.lines().map(|line| line.len() as u32).max().unwrap();
      
      // todo if after closure?
      self.skip_single_expr_blocks(body, |body| if arm_body_requires_block(body) {
          self.expr_add_block(body)
      } else if plain_block(body).is_some() {
          self.expr(body)
      } else {
          self.arm_body_add_block_if_first_line_is_longer(body)
      })?;
      
      
      // todo prefer not to overflow
      list(Braces::PARENS, &parenthesized_args.inputs, |af, ty, _lcx| {
          af.ty(ty)
      });
      
      // todo next should not add block
      self.backtrack()
          .next(|| {
              self.with_single_line(|| self.expr_tail(index, &Tail::token("]")))
          })
          .next(|| self.with_single_line(|| self.expr_tail(index, &Tail::token("]"))))
          .otherwise(|| self.embraced_after_opening("]", || self.expr(index)))?;
- name: another todo
  type: no_change
  formatted: |
    // #2158
    trait Foo {
        type ItRev = <MergingUntypedTimeSeries<SliceSeries<SliceWindow>> as UntypedTimeSeries>::IterRev;
        type IteRev = <MergingUntypedTimeSeries<SliceSeries<SliceWindow>> as UntypedTimeSeries>::IterRev;
    }

    // #2331
    trait MyTrait<AAAAAAAAAAAAAAAAAAAA, BBBBBBBBBBBBBBBBBBBB, CCCCCCCCCCCCCCCCCCCC, DDDDDDDDDDDDDDDDDDDD> {
        fn foo() {}
    }

    // Trait aliases
    trait FooBar =
        Foo 
        + Bar;
    trait FooBar <A, B, C>=
        Foo 
        + Bar;
    pub trait FooBar =
        Foo 
        + Bar;
    pub trait FooBar <A, B, C>=
        Foo 
        + Bar;
    trait AAAAAAAAAAAAAAAAAA = BBBBBBBBBBBBBBBBBBB + CCCCCCCCCCCCCCCCCCCCCCCCCCCCC + DDDDDDDDDDDDDDDDDD;
    pub trait AAAAAAAAAAAAAAAAAA = BBBBBBBBBBBBBBBBBBB + CCCCCCCCCCCCCCCCCCCCCCCCCCCCC + DDDDDDDDDDDDDDDDDD;
    trait AAAAAAAAAAAAAAAAAAA = BBBBBBBBBBBBBBBBBBB + CCCCCCCCCCCCCCCCCCCCCCCCCCCCC + DDDDDDDDDDDDDDDDDD;
    trait AAAAAAAAAAAAAAAAAA = BBBBBBBBBBBBBBBBBBB + CCCCCCCCCCCCCCCCCCCCCCCCCCCCC + DDDDDDDDDDDDDDDDDDD;
    trait AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<A, B, C, D, E> = FooBar;
    trait AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<A, B, C, D, E> = FooBar;
    #[rustfmt::skip]
    trait FooBar = Foo
        + Bar;

    // #2637
    auto trait Example {}
    pub auto trait PubExample {}
    pub unsafe auto trait PubUnsafeExample {}

    // #3006
    trait Foo<'a> {
        type Bar<  'a  >;
    }

    impl<'a> Foo<'a> for i32 {
        type Bar<  'a  > = i32;
    }

    // #3092
    pub mod test {
        pub trait ATraitWithALooongName {}
        pub trait ATrait
            :ATraitWithALooongName + ATraitWithALooongName + ATraitWithALooongName + ATraitWithALooongName
    {
    }
    }

    // Trait aliases with where clauses.
    trait A = where for<'b> &'b Self: Send;

    trait B = where for<'b> &'b Self: Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCC;
    trait B = where for<'b> &'b Self: Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCCC;
    trait B = where
        for<'b> &'b Self:
    Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCCCCCCCCCCCCCCC;
    trait B = where
        for<'b> &'b Self:
    Send + Clone + Copy + SomeTrait + AAAAAAAA + BBBBBBB + CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC;

    trait B = where
        for<'b> &'b Self:
    Send
        + Clone
        + Copy
        + SomeTrait
        + AAAAAAAA
        + BBBBBBB
        + CCCCCCCCC
        + DDDDDDD
        + DDDDDDDD
        + DDDDDDDDD
        + EEEEEEE;

    trait A<'a, 'b, 'c> = Debug<T> + Foo where for<'b> &'b Self: Send;

    trait B<'a, 'b, 'c> = Debug<T> +Foo
    where for<'b> &'b Self:
    Send
        + Clone
        + Copy
        + SomeTrait
        + AAAAAAAA
        + BBBBBBB
        + CCCCCCCCC
        + DDDDDDD;

    trait B<'a, 'b, 'c,T> = Debug<'a, T> where for<'b> &'b Self:
    Send
        + Clone
        + Copy
        + SomeTrait
        + AAAAAAAA
        + BBBBBBB
        + CCCCCCCCC
        + DDDDDDD
        + DDDDDDDD
        + DDDDDDDDD
        + EEEEEEE;

    trait Visible {
        pub const C: i32;
        pub type T;
        pub fn f();
        pub fn g() {}
    }
